// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file sf/ethereum/transform/v1/transforms.proto (package sf.ethereum.transform.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file sf/ethereum/transform/v1/transforms.proto.
 */
export const file_sf_ethereum_transform_v1_transforms: GenFile = /*@__PURE__*/
  fileDesc("CilzZi9ldGhlcmV1bS90cmFuc2Zvcm0vdjEvdHJhbnNmb3Jtcy5wcm90bxIYc2YuZXRoZXJldW0udHJhbnNmb3JtLnYxIqgBCg5Db21iaW5lZEZpbHRlchI4Cgtsb2dfZmlsdGVycxgBIAMoCzIjLnNmLmV0aGVyZXVtLnRyYW5zZm9ybS52MS5Mb2dGaWx0ZXISPAoMY2FsbF9maWx0ZXJzGAIgAygLMiYuc2YuZXRoZXJldW0udHJhbnNmb3JtLnYxLkNhbGxUb0ZpbHRlchIeChZzZW5kX2FsbF9ibG9ja19oZWFkZXJzGAMgASgIIkoKDk11bHRpTG9nRmlsdGVyEjgKC2xvZ19maWx0ZXJzGAEgAygLMiMuc2YuZXRoZXJldW0udHJhbnNmb3JtLnYxLkxvZ0ZpbHRlciI4CglMb2dGaWx0ZXISEQoJYWRkcmVzc2VzGAEgAygMEhgKEGV2ZW50X3NpZ25hdHVyZXMYAiADKAwiUQoRTXVsdGlDYWxsVG9GaWx0ZXISPAoMY2FsbF9maWx0ZXJzGAEgAygLMiYuc2YuZXRoZXJldW0udHJhbnNmb3JtLnYxLkNhbGxUb0ZpbHRlciI1CgxDYWxsVG9GaWx0ZXISEQoJYWRkcmVzc2VzGAEgAygMEhIKCnNpZ25hdHVyZXMYAiADKAwiDAoKSGVhZGVyT25seUJaWlhnaXRodWIuY29tL3N0cmVhbWluZ2Zhc3QvZmlyZWhvc2UtZXRoZXJldW0vdHlwZXMvcGIvc2YvZXRoZXJldW0vdHJhbnNmb3JtL3YxO3BidHJhbnNmb3JtYgZwcm90bzM");

/**
 * CombinedFilter is a combination of "LogFilters" and "CallToFilters"
 *
 * It transforms the requested stream in two ways:
 *   1. STRIPPING
 *      The block data is stripped from all transactions that don't
 *      match any of the filters.
 *
 *   2. SKIPPING
 *      If an "block index" covers a range containing a
 *      block that does NOT match any of the filters, the block will be
 *      skipped altogether, UNLESS send_all_block_headers is enabled
 *      In that case, the block would still be sent, but without any
 *      transactionTrace
 *
 * The SKIPPING feature only applies to historical blocks, because
 * the "block index" is always produced after the merged-blocks files
 * are produced. Therefore, the "live" blocks are never filtered out.
 *
 *
 * @generated from message sf.ethereum.transform.v1.CombinedFilter
 */
export type CombinedFilter = Message<"sf.ethereum.transform.v1.CombinedFilter"> & {
  /**
   * @generated from field: repeated sf.ethereum.transform.v1.LogFilter log_filters = 1;
   */
  logFilters: LogFilter[];

  /**
   * @generated from field: repeated sf.ethereum.transform.v1.CallToFilter call_filters = 2;
   */
  callFilters: CallToFilter[];

  /**
   * Always send all blocks. if they don't match any log_filters or call_filters,
   * all the transactions will be filtered out, sending only the header.
   *
   * @generated from field: bool send_all_block_headers = 3;
   */
  sendAllBlockHeaders: boolean;
};

/**
 * Describes the message sf.ethereum.transform.v1.CombinedFilter.
 * Use `create(CombinedFilterSchema)` to create a new message.
 */
export const CombinedFilterSchema: GenMessage<CombinedFilter> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_transform_v1_transforms, 0);

/**
 * MultiLogFilter concatenates the results of each LogFilter (inclusive OR)
 *
 * @generated from message sf.ethereum.transform.v1.MultiLogFilter
 */
export type MultiLogFilter = Message<"sf.ethereum.transform.v1.MultiLogFilter"> & {
  /**
   * @generated from field: repeated sf.ethereum.transform.v1.LogFilter log_filters = 1;
   */
  logFilters: LogFilter[];
};

/**
 * Describes the message sf.ethereum.transform.v1.MultiLogFilter.
 * Use `create(MultiLogFilterSchema)` to create a new message.
 */
export const MultiLogFilterSchema: GenMessage<MultiLogFilter> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_transform_v1_transforms, 1);

/**
 * LogFilter will match calls where *BOTH*
 * * the contract address that emits the log is one in the provided addresses -- OR addresses list is empty --
 * * the event signature (topic.0) is one of the provided event_signatures -- OR event_signatures is empty --
 *
 * a LogFilter with both empty addresses and event_signatures lists is invalid and will fail.
 *
 * @generated from message sf.ethereum.transform.v1.LogFilter
 */
export type LogFilter = Message<"sf.ethereum.transform.v1.LogFilter"> & {
  /**
   * @generated from field: repeated bytes addresses = 1;
   */
  addresses: Uint8Array[];

  /**
   * corresponds to the keccak of the event signature which is stores in topic.0
   *
   * @generated from field: repeated bytes event_signatures = 2;
   */
  eventSignatures: Uint8Array[];
};

/**
 * Describes the message sf.ethereum.transform.v1.LogFilter.
 * Use `create(LogFilterSchema)` to create a new message.
 */
export const LogFilterSchema: GenMessage<LogFilter> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_transform_v1_transforms, 2);

/**
 * MultiCallToFilter concatenates the results of each CallToFilter (inclusive OR)
 *
 * @generated from message sf.ethereum.transform.v1.MultiCallToFilter
 */
export type MultiCallToFilter = Message<"sf.ethereum.transform.v1.MultiCallToFilter"> & {
  /**
   * @generated from field: repeated sf.ethereum.transform.v1.CallToFilter call_filters = 1;
   */
  callFilters: CallToFilter[];
};

/**
 * Describes the message sf.ethereum.transform.v1.MultiCallToFilter.
 * Use `create(MultiCallToFilterSchema)` to create a new message.
 */
export const MultiCallToFilterSchema: GenMessage<MultiCallToFilter> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_transform_v1_transforms, 3);

/**
 * CallToFilter will match calls where *BOTH*
 * * the contract address (TO) is one in the provided addresses -- OR addresses list is empty --
 * * the method signature (in 4-bytes format) is one of the provided signatures -- OR signatures is empty --
 *
 * a CallToFilter with both empty addresses and signatures lists is invalid and will fail.
 *
 * @generated from message sf.ethereum.transform.v1.CallToFilter
 */
export type CallToFilter = Message<"sf.ethereum.transform.v1.CallToFilter"> & {
  /**
   * @generated from field: repeated bytes addresses = 1;
   */
  addresses: Uint8Array[];

  /**
   * @generated from field: repeated bytes signatures = 2;
   */
  signatures: Uint8Array[];
};

/**
 * Describes the message sf.ethereum.transform.v1.CallToFilter.
 * Use `create(CallToFilterSchema)` to create a new message.
 */
export const CallToFilterSchema: GenMessage<CallToFilter> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_transform_v1_transforms, 4);

/**
 * HeaderOnly returns only the block's header and few top-level core information for the block. Useful
 * for cases where no transactions information is required at all.
 *
 * The structure that would will have access to after:
 *
 * ```
 * Block {
 *  int32 ver = 1;
 *  bytes hash = 2;
 *  uint64 number = 3;
 *  uint64 size = 4;
 *  BlockHeader header = 5;
 * }
 * ```
 *
 * Everything else will be empty.
 *
 * @generated from message sf.ethereum.transform.v1.HeaderOnly
 */
export type HeaderOnly = Message<"sf.ethereum.transform.v1.HeaderOnly"> & {
};

/**
 * Describes the message sf.ethereum.transform.v1.HeaderOnly.
 * Use `create(HeaderOnlySchema)` to create a new message.
 */
export const HeaderOnlySchema: GenMessage<HeaderOnly> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_transform_v1_transforms, 5);

