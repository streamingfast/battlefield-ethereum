import { expect } from "chai"
import { fetchFirehoseBlock, fetchFirehoseTransactionAndBlock } from "./lib/firehose"
import { sendEth } from "./lib/ethereum"
import { knownExistingAddress } from "./lib/addresses"
import { owner } from "./global"
import { oneWei } from "./lib/money"
import { isNetwork } from "./lib/network"

if (isNetwork("polygon-dev")) {
  describe("Polygon", function () {
    it("Polygon System Transaction", async function () {
      const firehoseBlock = await fetchFirehoseBlock(64)
      expect(firehoseBlock.transactionTraces).to.have.lengthOf(1)
      const tx = firehoseBlock.transactionTraces[0]
      await expect(
        [tx, firehoseBlock]
      ).to.trxTraceEqualSnapshot("system_tx/validator_update.expected.json", {
      })
    })

    it("Polygon ETH Transfer Logs", async function () {
      const result = await sendEth(owner, knownExistingAddress, oneWei)
      const { block, trace } = await fetchFirehoseTransactionAndBlock(result)
      expect(block.number).to.be.equal(result.blockNumber)

      const util = require('util')

      // Verify top-level logs
      expect(trace.receipt).to.not.be.undefined
      expect(trace.receipt!.$typeName).to.equal("sf.ethereum.type.v2.TransactionReceipt")
      expect(trace.receipt!.stateRoot).to.deep.equal(new Uint8Array(0))
      expect(trace.receipt!.cumulativeGasUsed).to.be.a('bigint')
      expect(trace.receipt!.logsBloom).to.be.instanceOf(Buffer)
      expect(trace.receipt!.logsBloom).to.have.lengthOf(256)
      expect(trace.receipt!.logs).to.be.an('array')
      expect(trace.receipt!.logs).to.have.lengthOf(2)

      const receiptLog1 = trace.receipt!.logs[0]
      expect(receiptLog1.$typeName).to.equal("sf.ethereum.type.v2.Log")
      expect(receiptLog1.address).to.be.instanceOf(Buffer).with.lengthOf(20)
      expect(receiptLog1.topics).to.be.an('array').with.lengthOf(4)
      expect(receiptLog1.topics[0]).to.deep.equal(Buffer.from([0xe6, 0x49, 0x7e, 0x3e, 0xe5, 0x48, 0xa3, 0x37, 0x21, 0x36, 0xaf, 0x2f, 0xcb, 0x06, 0x96, 0xdb, 0x31, 0xfc, 0x6c, 0xf2, 0x02, 0x60, 0x70, 0x76, 0x45, 0x06, 0x8b, 0xd3, 0xfe, 0x97, 0xf3, 0xc4]))
      expect(receiptLog1.topics[1]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10]))
      expect(receiptLog1.topics[2]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x1b, 0x55, 0xd8, 0xab, 0xe7, 0x9b, 0xc9, 0x8f, 0x05, 0xeb, 0x67, 0x5f, 0xdc, 0x50, 0xdf, 0xe7, 0x96, 0xb7, 0xab]))
      expect(receiptLog1.topics[3]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd5, 0x49, 0xd2, 0xfd, 0x4b, 0x17, 0x77, 0x67, 0xb8, 0x4a, 0xb2, 0xfd, 0x17, 0x42, 0x3c, 0xee, 0x1c, 0xf1, 0xd7, 0xbd]))
      expect(receiptLog1.data).to.be.instanceOf(Buffer).with.lengthOf(160)
      expect(receiptLog1.data.slice(0, 32)).to.deep.equal(Buffer.from("0000000000000000000000000000000000000000000000000000000000000001", "hex"))
      expect(receiptLog1.index).to.equal(0)
      expect(receiptLog1.blockIndex).to.be.a('number')
      expect(receiptLog1.ordinal).to.be.a('bigint')

      const receiptLog2 = trace.receipt!.logs[1]
      expect(receiptLog2.$typeName).to.equal("sf.ethereum.type.v2.Log")
      expect(receiptLog2.address).to.be.instanceOf(Buffer).with.lengthOf(20)
      expect(receiptLog2.topics).to.be.an('array').with.lengthOf(4)
      expect(receiptLog2.topics[0]).to.deep.equal(Buffer.from([0x4d, 0xfe, 0x1b, 0xbb, 0xcf, 0x07, 0x7d, 0xdc, 0x3e, 0x01, 0x29, 0x1e, 0xea, 0x2d, 0x5c, 0x70, 0xc2, 0xb4, 0x22, 0xb4, 0x15, 0xd9, 0x56, 0x45, 0xb9, 0xad, 0xcf, 0xd6, 0x78, 0xcb, 0x1d, 0x63]))
      expect(receiptLog2.topics[1]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10]))
      expect(receiptLog2.topics[2]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x1b, 0x55, 0xd8, 0xab, 0xe7, 0x9b, 0xc9, 0x8f, 0x05, 0xeb, 0x67, 0x5f, 0xdc, 0x50, 0xdf, 0xe7, 0x96, 0xb7, 0xab]))
      expect(receiptLog2.topics[3]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x96, 0xa1, 0xa1, 0xe2, 0x1a, 0x53, 0xe1, 0xba, 0xa3, 0xa0, 0xa5, 0xa2, 0xa1, 0x20, 0x35, 0x71, 0xb2, 0x50, 0xcd]))
      expect(receiptLog2.data).to.be.instanceOf(Buffer).with.lengthOf(160)
      expect(receiptLog2.data.slice(0, 29)).to.deep.equal(Buffer.from("00000000000000000000000000000000000000000000000000035b78f5", "hex"))
      expect(receiptLog2.index).to.equal(1)
      expect(receiptLog2.blockIndex).to.be.a('number')
      expect(receiptLog2.ordinal).to.be.a('bigint')

      expect(receiptLog2.ordinal).to.be.greaterThan(receiptLog1.ordinal)

      // Verify internal calls
      expect(trace.calls).to.be.an('array')
      expect(trace.calls).to.have.lengthOf(1)

      const singleCall = trace.calls[0]
      expect(singleCall).to.exist
      expect(singleCall.index).to.equal(1)
      expect(singleCall.parentIndex).to.equal(0)
      expect(singleCall.depth).to.equal(0)
      expect(singleCall.callType).to.equal(1)
      expect(singleCall.logs).to.be.an("array").with.lengthOf(2)

      const log1 = singleCall.logs[0]
      expect(log1.$typeName).to.equal("sf.ethereum.type.v2.Log")
      expect(log1.address).to.be.instanceOf(Buffer).with.lengthOf(20)
      expect(log1.topics).to.be.an('array').with.lengthOf(4)
      expect(log1.topics[0]).to.deep.equal(Buffer.from([0xe6, 0x49, 0x7e, 0x3e, 0xe5, 0x48, 0xa3, 0x37, 0x21, 0x36, 0xaf, 0x2f, 0xcb, 0x06, 0x96, 0xdb, 0x31, 0xfc, 0x6c, 0xf2, 0x02, 0x60, 0x70, 0x76, 0x45, 0x06, 0x8b, 0xd3, 0xfe, 0x97, 0xf3, 0xc4]))
      expect(log1.topics[1]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10]))
      expect(log1.topics[2]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x1b, 0x55, 0xd8, 0xab, 0xe7, 0x9b, 0xc9, 0x8f, 0x05, 0xeb, 0x67, 0x5f, 0xdc, 0x50, 0xdf, 0xe7, 0x96, 0xb7, 0xab]))
      expect(log1.topics[3]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd5, 0x49, 0xd2, 0xfd, 0x4b, 0x17, 0x77, 0x67, 0xb8, 0x4a, 0xb2, 0xfd, 0x17, 0x42, 0x3c, 0xee, 0x1c, 0xf1, 0xd7, 0xbd]))
      expect(log1.data).to.be.instanceOf(Buffer).with.lengthOf(160)
      expect(log1.data.slice(0, 32)).to.deep.equal(Buffer.from("0000000000000000000000000000000000000000000000000000000000000001", "hex"))
      expect(log1.index).to.equal(0)
      expect(log1.blockIndex).to.be.a('number')
      expect(log1.ordinal).to.be.a('bigint')

      const log2 = singleCall.logs[1]
      expect(log2.$typeName).to.equal("sf.ethereum.type.v2.Log")
      expect(log2.address).to.be.instanceOf(Buffer).with.lengthOf(20)
      expect(log2.topics).to.be.an('array').with.lengthOf(4)
      expect(log2.topics[0]).to.deep.equal(Buffer.from([0x4d, 0xfe, 0x1b, 0xbb, 0xcf, 0x07, 0x7d, 0xdc, 0x3e, 0x01, 0x29, 0x1e, 0xea, 0x2d, 0x5c, 0x70, 0xc2, 0xb4, 0x22, 0xb4, 0x15, 0xd9, 0x56, 0x45, 0xb9, 0xad, 0xcf, 0xd6, 0x78, 0xcb, 0x1d, 0x63]))
      expect(log2.topics[1]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10]))
      expect(log2.topics[2]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x1b, 0x55, 0xd8, 0xab, 0xe7, 0x9b, 0xc9, 0x8f, 0x05, 0xeb, 0x67, 0x5f, 0xdc, 0x50, 0xdf, 0xe7, 0x96, 0xb7, 0xab]))
      expect(log2.topics[3]).to.deep.equal(Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x96, 0xa1, 0xa1, 0xe2, 0x1a, 0x53, 0xe1, 0xba, 0xa3, 0xa0, 0xa5, 0xa2, 0xa1, 0x20, 0x35, 0x71, 0xb2, 0x50, 0xcd]))
      expect(log2.data).to.be.instanceOf(Buffer).with.lengthOf(160)
      expect(log2.data.slice(0, 29)).to.deep.equal(Buffer.from("00000000000000000000000000000000000000000000000000035b78f5", "hex"))
      expect(log2.index).to.equal(1)
      expect(log2.blockIndex).to.be.a('number')
      expect(log2.ordinal).to.be.a('bigint')

      expect(log2.ordinal).to.be.greaterThan(log1.ordinal)
    })
  })
}

if (isNetwork("amoy")) {
  describe("Amoy", function (){
    it("Validate unmergeable system tx (block 16)", async function () {
      const block = await fetchFirehoseBlock(16)
      expect(block).to.exist
      expect(block.number).to.be.equal(16)
      expect(block.transactionTraces).to.have.lengthOf(1)
      const tx = block.transactionTraces[0]
      await expect(
        [tx, block]
      ).to.trxTraceEqualSnapshot("system_tx/unmergeable_system_tx_hash.json")
    })
  })
}
