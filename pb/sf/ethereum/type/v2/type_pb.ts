// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file sf/ethereum/type/v2/type.proto (package sf.ethereum.type.v2, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file sf/ethereum/type/v2/type.proto.
 */
export const file_sf_ethereum_type_v2_type: GenFile = /*@__PURE__*/
  fileDesc("Ch5zZi9ldGhlcmV1bS90eXBlL3YyL3R5cGUucHJvdG8SE3NmLmV0aGVyZXVtLnR5cGUudjIimwQKBUJsb2NrEgwKBGhhc2gYAiABKAwSDgoGbnVtYmVyGAMgASgEEgwKBHNpemUYBCABKAQSMAoGaGVhZGVyGAUgASgLMiAuc2YuZXRoZXJldW0udHlwZS52Mi5CbG9ja0hlYWRlchIwCgZ1bmNsZXMYBiADKAsyIC5zZi5ldGhlcmV1bS50eXBlLnYyLkJsb2NrSGVhZGVyEkEKEnRyYW5zYWN0aW9uX3RyYWNlcxgKIAMoCzIlLnNmLmV0aGVyZXVtLnR5cGUudjIuVHJhbnNhY3Rpb25UcmFjZRI7Cg9iYWxhbmNlX2NoYW5nZXMYCyADKAsyIi5zZi5ldGhlcmV1bS50eXBlLnYyLkJhbGFuY2VDaGFuZ2USPAoMZGV0YWlsX2xldmVsGAwgASgOMiYuc2YuZXRoZXJldW0udHlwZS52Mi5CbG9jay5EZXRhaWxMZXZlbBI1Cgxjb2RlX2NoYW5nZXMYFCADKAsyHy5zZi5ldGhlcmV1bS50eXBlLnYyLkNvZGVDaGFuZ2USLwoMc3lzdGVtX2NhbGxzGBUgAygLMhkuc2YuZXRoZXJldW0udHlwZS52Mi5DYWxsEgsKA3ZlchgBIAEoBSI9CgtEZXRhaWxMZXZlbBIYChRERVRBSUxMRVZFTF9FWFRFTkRFRBAAEhQKEERFVEFJTExFVkVMX0JBU0UQAkoECCgQKUoECCkQKkoECCoQKyLTBQoLQmxvY2tIZWFkZXISEwoLcGFyZW50X2hhc2gYASABKAwSEgoKdW5jbGVfaGFzaBgCIAEoDBIQCghjb2luYmFzZRgDIAEoDBISCgpzdGF0ZV9yb290GAQgASgMEhkKEXRyYW5zYWN0aW9uc19yb290GAUgASgMEhQKDHJlY2VpcHRfcm9vdBgGIAEoDBISCgpsb2dzX2Jsb29tGAcgASgMEi8KCmRpZmZpY3VsdHkYCCABKAsyGy5zZi5ldGhlcmV1bS50eXBlLnYyLkJpZ0ludBI1ChB0b3RhbF9kaWZmaWN1bHR5GBEgASgLMhsuc2YuZXRoZXJldW0udHlwZS52Mi5CaWdJbnQSDgoGbnVtYmVyGAkgASgEEhEKCWdhc19saW1pdBgKIAEoBBIQCghnYXNfdXNlZBgLIAEoBBItCgl0aW1lc3RhbXAYDCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhIKCmV4dHJhX2RhdGEYDSABKAwSEAoIbWl4X2hhc2gYDiABKAwSDQoFbm9uY2UYDyABKAQSDAoEaGFzaBgQIAEoDBI1ChBiYXNlX2ZlZV9wZXJfZ2FzGBIgASgLMhsuc2YuZXRoZXJldW0udHlwZS52Mi5CaWdJbnQSGAoQd2l0aGRyYXdhbHNfcm9vdBgTIAEoDBI9Cg10eF9kZXBlbmRlbmN5GBQgASgLMiYuc2YuZXRoZXJldW0udHlwZS52Mi5VaW50NjROZXN0ZWRBcnJheRIaCg1ibG9iX2dhc191c2VkGBYgASgESACIAQESHAoPZXhjZXNzX2Jsb2JfZ2FzGBcgASgESAGIAQESGgoScGFyZW50X2JlYWNvbl9yb290GBggASgMEhUKDXJlcXVlc3RzX2hhc2gYGSABKAxCEAoOX2Jsb2JfZ2FzX3VzZWRCEgoQX2V4Y2Vzc19ibG9iX2dhcyJCChFVaW50NjROZXN0ZWRBcnJheRItCgN2YWwYASADKAsyIC5zZi5ldGhlcmV1bS50eXBlLnYyLlVpbnQ2NEFycmF5IhoKC1VpbnQ2NEFycmF5EgsKA3ZhbBgBIAMoBCIXCgZCaWdJbnQSDQoFYnl0ZXMYASABKAwi1QkKEFRyYW5zYWN0aW9uVHJhY2USCgoCdG8YASABKAwSDQoFbm9uY2UYAiABKAQSLgoJZ2FzX3ByaWNlGAMgASgLMhsuc2YuZXRoZXJldW0udHlwZS52Mi5CaWdJbnQSEQoJZ2FzX2xpbWl0GAQgASgEEioKBXZhbHVlGAUgASgLMhsuc2YuZXRoZXJldW0udHlwZS52Mi5CaWdJbnQSDQoFaW5wdXQYBiABKAwSCQoBdhgHIAEoDBIJCgFyGAggASgMEgkKAXMYCSABKAwSEAoIZ2FzX3VzZWQYCiABKAQSOAoEdHlwZRgMIAEoDjIqLnNmLmV0aGVyZXVtLnR5cGUudjIuVHJhbnNhY3Rpb25UcmFjZS5UeXBlEjUKC2FjY2Vzc19saXN0GA4gAygLMiAuc2YuZXRoZXJldW0udHlwZS52Mi5BY2Nlc3NUdXBsZRI0Cg9tYXhfZmVlX3Blcl9nYXMYCyABKAsyGy5zZi5ldGhlcmV1bS50eXBlLnYyLkJpZ0ludBI9ChhtYXhfcHJpb3JpdHlfZmVlX3Blcl9nYXMYDSABKAsyGy5zZi5ldGhlcmV1bS50eXBlLnYyLkJpZ0ludBINCgVpbmRleBgUIAEoDRIMCgRoYXNoGBUgASgMEgwKBGZyb20YFiABKAwSEwoLcmV0dXJuX2RhdGEYFyABKAwSEgoKcHVibGljX2tleRgYIAEoDBIVCg1iZWdpbl9vcmRpbmFsGBkgASgEEhMKC2VuZF9vcmRpbmFsGBogASgEEjsKBnN0YXR1cxgeIAEoDjIrLnNmLmV0aGVyZXVtLnR5cGUudjIuVHJhbnNhY3Rpb25UcmFjZVN0YXR1cxI4CgdyZWNlaXB0GB8gASgLMicuc2YuZXRoZXJldW0udHlwZS52Mi5UcmFuc2FjdGlvblJlY2VpcHQSKAoFY2FsbHMYICADKAsyGS5zZi5ldGhlcmV1bS50eXBlLnYyLkNhbGwSFQoIYmxvYl9nYXMYISABKARIAIgBARI6ChBibG9iX2dhc19mZWVfY2FwGCIgASgLMhsuc2YuZXRoZXJldW0udHlwZS52Mi5CaWdJbnRIAYgBARITCgtibG9iX2hhc2hlcxgjIAMoDCLjAgoEVHlwZRITCg9UUlhfVFlQRV9MRUdBQ1kQABIYChRUUlhfVFlQRV9BQ0NFU1NfTElTVBABEhgKFFRSWF9UWVBFX0RZTkFNSUNfRkVFEAISEQoNVFJYX1RZUEVfQkxPQhADEh0KGVRSWF9UWVBFX0FSQklUUlVNX0RFUE9TSVQQZBIeChpUUlhfVFlQRV9BUkJJVFJVTV9VTlNJR05FRBBlEh4KGlRSWF9UWVBFX0FSQklUUlVNX0NPTlRSQUNUEGYSGwoXVFJYX1RZUEVfQVJCSVRSVU1fUkVUUlkQaBImCiJUUlhfVFlQRV9BUkJJVFJVTV9TVUJNSVRfUkVUUllBQkxFEGkSHgoaVFJYX1RZUEVfQVJCSVRSVU1fSU5URVJOQUwQahIcChhUUlhfVFlQRV9BUkJJVFJVTV9MRUdBQ1kQeBIdChlUUlhfVFlQRV9PUFRJTUlTTV9ERVBPU0lUEH5CCwoJX2Jsb2JfZ2FzQhMKEV9ibG9iX2dhc19mZWVfY2FwIjQKC0FjY2Vzc1R1cGxlEg8KB2FkZHJlc3MYASABKAwSFAoMc3RvcmFnZV9rZXlzGAIgAygMIvwBChJUcmFuc2FjdGlvblJlY2VpcHQSEgoKc3RhdGVfcm9vdBgBIAEoDBIbChNjdW11bGF0aXZlX2dhc191c2VkGAIgASgEEhIKCmxvZ3NfYmxvb20YAyABKAwSJgoEbG9ncxgEIAMoCzIYLnNmLmV0aGVyZXVtLnR5cGUudjIuTG9nEhoKDWJsb2JfZ2FzX3VzZWQYBSABKARIAIgBARI4Cg5ibG9iX2dhc19wcmljZRgGIAEoCzIbLnNmLmV0aGVyZXVtLnR5cGUudjIuQmlnSW50SAGIAQFCEAoOX2Jsb2JfZ2FzX3VzZWRCEQoPX2Jsb2JfZ2FzX3ByaWNlImgKA0xvZxIPCgdhZGRyZXNzGAEgASgMEg4KBnRvcGljcxgCIAMoDBIMCgRkYXRhGAMgASgMEg0KBWluZGV4GAQgASgNEhIKCmJsb2NrSW5kZXgYBiABKA0SDwoHb3JkaW5hbBgHIAEoBCLiBwoEQ2FsbBINCgVpbmRleBgBIAEoDRIUCgxwYXJlbnRfaW5kZXgYAiABKA0SDQoFZGVwdGgYAyABKA0SMAoJY2FsbF90eXBlGAQgASgOMh0uc2YuZXRoZXJldW0udHlwZS52Mi5DYWxsVHlwZRIOCgZjYWxsZXIYBSABKAwSDwoHYWRkcmVzcxgGIAEoDBIqCgV2YWx1ZRgHIAEoCzIbLnNmLmV0aGVyZXVtLnR5cGUudjIuQmlnSW50EhEKCWdhc19saW1pdBgIIAEoBBIUCgxnYXNfY29uc3VtZWQYCSABKAQSEwoLcmV0dXJuX2RhdGEYDSABKAwSDQoFaW5wdXQYDiABKAwSFQoNZXhlY3V0ZWRfY29kZRgPIAEoCBIPCgdzdWljaWRlGBAgASgIEkgKEGtlY2Nha19wcmVpbWFnZXMYFCADKAsyLi5zZi5ldGhlcmV1bS50eXBlLnYyLkNhbGwuS2VjY2FrUHJlaW1hZ2VzRW50cnkSOwoPc3RvcmFnZV9jaGFuZ2VzGBUgAygLMiIuc2YuZXRoZXJldW0udHlwZS52Mi5TdG9yYWdlQ2hhbmdlEjsKD2JhbGFuY2VfY2hhbmdlcxgWIAMoCzIiLnNmLmV0aGVyZXVtLnR5cGUudjIuQmFsYW5jZUNoYW5nZRI3Cg1ub25jZV9jaGFuZ2VzGBggAygLMiAuc2YuZXRoZXJldW0udHlwZS52Mi5Ob25jZUNoYW5nZRImCgRsb2dzGBkgAygLMhguc2YuZXRoZXJldW0udHlwZS52Mi5Mb2cSNQoMY29kZV9jaGFuZ2VzGBogAygLMh8uc2YuZXRoZXJldW0udHlwZS52Mi5Db2RlQ2hhbmdlEjMKC2dhc19jaGFuZ2VzGBwgAygLMh4uc2YuZXRoZXJldW0udHlwZS52Mi5HYXNDaGFuZ2USFQoNc3RhdHVzX2ZhaWxlZBgKIAEoCBIXCg9zdGF0dXNfcmV2ZXJ0ZWQYDCABKAgSFgoOZmFpbHVyZV9yZWFzb24YCyABKAkSFgoOc3RhdGVfcmV2ZXJ0ZWQYHiABKAgSFQoNYmVnaW5fb3JkaW5hbBgfIAEoBBITCgtlbmRfb3JkaW5hbBggIAEoBBI/ChFhY2NvdW50X2NyZWF0aW9ucxghIAMoCzIkLnNmLmV0aGVyZXVtLnR5cGUudjIuQWNjb3VudENyZWF0aW9uGjYKFEtlY2Nha1ByZWltYWdlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAFKBAgbEBxKBAgdEB5KBAgyEDNKBAgzEDRKBAg8ED0iZAoNU3RvcmFnZUNoYW5nZRIPCgdhZGRyZXNzGAEgASgMEgsKA2tleRgCIAEoDBIRCglvbGRfdmFsdWUYAyABKAwSEQoJbmV3X3ZhbHVlGAQgASgMEg8KB29yZGluYWwYBSABKAQi1AUKDUJhbGFuY2VDaGFuZ2USDwoHYWRkcmVzcxgBIAEoDBIuCglvbGRfdmFsdWUYAiABKAsyGy5zZi5ldGhlcmV1bS50eXBlLnYyLkJpZ0ludBIuCgluZXdfdmFsdWUYAyABKAsyGy5zZi5ldGhlcmV1bS50eXBlLnYyLkJpZ0ludBI5CgZyZWFzb24YBCABKA4yKS5zZi5ldGhlcmV1bS50eXBlLnYyLkJhbGFuY2VDaGFuZ2UuUmVhc29uEg8KB29yZGluYWwYBSABKAQihQQKBlJlYXNvbhISCg5SRUFTT05fVU5LTk9XThAAEhwKGFJFQVNPTl9SRVdBUkRfTUlORV9VTkNMRRABEhwKGFJFQVNPTl9SRVdBUkRfTUlORV9CTE9DSxACEh4KGlJFQVNPTl9EQU9fUkVGVU5EX0NPTlRSQUNUEAMSHQoZUkVBU09OX0RBT19BREpVU1RfQkFMQU5DRRAEEhMKD1JFQVNPTl9UUkFOU0ZFUhAFEhoKFlJFQVNPTl9HRU5FU0lTX0JBTEFOQ0UQBhISCg5SRUFTT05fR0FTX0JVWRAHEiEKHVJFQVNPTl9SRVdBUkRfVFJBTlNBQ1RJT05fRkVFEAgSGwoXUkVBU09OX1JFV0FSRF9GRUVfUkVTRVQQDhIVChFSRUFTT05fR0FTX1JFRlVORBAJEhgKFFJFQVNPTl9UT1VDSF9BQ0NPVU5UEAoSGQoVUkVBU09OX1NVSUNJREVfUkVGVU5EEAsSGwoXUkVBU09OX1NVSUNJREVfV0lUSERSQVcQDRIgChxSRUFTT05fQ0FMTF9CQUxBTkNFX09WRVJSSURFEAwSDwoLUkVBU09OX0JVUk4QDxIVChFSRUFTT05fV0lUSERSQVdBTBAQEhoKFlJFQVNPTl9SRVdBUkRfQkxPQl9GRUUQERIYChRSRUFTT05fSU5DUkVBU0VfTUlOVBASIlUKC05vbmNlQ2hhbmdlEg8KB2FkZHJlc3MYASABKAwSEQoJb2xkX3ZhbHVlGAIgASgEEhEKCW5ld192YWx1ZRgDIAEoBBIPCgdvcmRpbmFsGAQgASgEIjMKD0FjY291bnRDcmVhdGlvbhIPCgdhY2NvdW50GAEgASgMEg8KB29yZGluYWwYAiABKAQidgoKQ29kZUNoYW5nZRIPCgdhZGRyZXNzGAEgASgMEhAKCG9sZF9oYXNoGAIgASgMEhAKCG9sZF9jb2RlGAMgASgMEhAKCG5ld19oYXNoGAQgASgMEhAKCG5ld19jb2RlGAUgASgMEg8KB29yZGluYWwYBiABKAQiuwYKCUdhc0NoYW5nZRIRCglvbGRfdmFsdWUYASABKAQSEQoJbmV3X3ZhbHVlGAIgASgEEjUKBnJlYXNvbhgDIAEoDjIlLnNmLmV0aGVyZXVtLnR5cGUudjIuR2FzQ2hhbmdlLlJlYXNvbhIPCgdvcmRpbmFsGAQgASgEIr8FCgZSZWFzb24SEgoOUkVBU09OX1VOS05PV04QABIPCgtSRUFTT05fQ0FMTBABEhQKEFJFQVNPTl9DQUxMX0NPREUQAhIZChVSRUFTT05fQ0FMTF9EQVRBX0NPUFkQAxIUChBSRUFTT05fQ09ERV9DT1BZEAQSFwoTUkVBU09OX0NPREVfU1RPUkFHRRAFEhwKGFJFQVNPTl9DT05UUkFDVF9DUkVBVElPThAGEh0KGVJFQVNPTl9DT05UUkFDVF9DUkVBVElPTjIQBxIYChRSRUFTT05fREVMRUdBVEVfQ0FMTBAIEhQKEFJFQVNPTl9FVkVOVF9MT0cQCRIYChRSRUFTT05fRVhUX0NPREVfQ09QWRAKEhsKF1JFQVNPTl9GQUlMRURfRVhFQ1VUSU9OEAsSGAoUUkVBU09OX0lOVFJJTlNJQ19HQVMQDBIfChtSRUFTT05fUFJFQ09NUElMRURfQ09OVFJBQ1QQDRIhCh1SRUFTT05fUkVGVU5EX0FGVEVSX0VYRUNVVElPThAOEhEKDVJFQVNPTl9SRVRVUk4QDxIbChdSRUFTT05fUkVUVVJOX0RBVEFfQ09QWRAQEhEKDVJFQVNPTl9SRVZFUlQQERIYChRSRUFTT05fU0VMRl9ERVNUUlVDVBASEhYKElJFQVNPTl9TVEFUSUNfQ0FMTBATEhwKGFJFQVNPTl9TVEFURV9DT0xEX0FDQ0VTUxAUEh0KGVJFQVNPTl9UWF9JTklUSUFMX0JBTEFOQ0UQFRIVChFSRUFTT05fVFhfUkVGVU5EUxAWEiAKHFJFQVNPTl9UWF9MRUZUX09WRVJfUkVUVVJORUQQFxIfChtSRUFTT05fQ0FMTF9JTklUSUFMX0JBTEFOQ0UQGBIiCh5SRUFTT05fQ0FMTF9MRUZUX09WRVJfUkVUVVJORUQQGSJDCg9IZWFkZXJPbmx5QmxvY2sSMAoGaGVhZGVyGAUgASgLMiAuc2YuZXRoZXJldW0udHlwZS52Mi5CbG9ja0hlYWRlciKiAQoNQmxvY2tXaXRoUmVmcxIKCgJpZBgBIAEoCRIpCgVibG9jaxgCIAEoCzIaLnNmLmV0aGVyZXVtLnR5cGUudjIuQmxvY2sSRAoWdHJhbnNhY3Rpb25fdHJhY2VfcmVmcxgDIAEoCzIkLnNmLmV0aGVyZXVtLnR5cGUudjIuVHJhbnNhY3Rpb25SZWZzEhQKDGlycmV2ZXJzaWJsZRgEIAEoCCKGAQocVHJhbnNhY3Rpb25UcmFjZVdpdGhCbG9ja1JlZhI0CgV0cmFjZRgBIAEoCzIlLnNmLmV0aGVyZXVtLnR5cGUudjIuVHJhbnNhY3Rpb25UcmFjZRIwCglibG9ja19yZWYYAiABKAsyHS5zZi5ldGhlcmV1bS50eXBlLnYyLkJsb2NrUmVmIiEKD1RyYW5zYWN0aW9uUmVmcxIOCgZoYXNoZXMYASADKAwiKAoIQmxvY2tSZWYSDAoEaGFzaBgBIAEoDBIOCgZudW1iZXIYAiABKAQqTgoWVHJhbnNhY3Rpb25UcmFjZVN0YXR1cxILCgdVTktOT1dOEAASDQoJU1VDQ0VFREVEEAESCgoGRkFJTEVEEAISDAoIUkVWRVJURUQQAypZCghDYWxsVHlwZRIPCgtVTlNQRUNJRklFRBAAEggKBENBTEwQARIMCghDQUxMQ09ERRACEgwKCERFTEVHQVRFEAMSCgoGU1RBVElDEAQSCgoGQ1JFQVRFEAVCT1pNZ2l0aHViLmNvbS9zdHJlYW1pbmdmYXN0L2ZpcmVob3NlLWV0aGVyZXVtL3R5cGVzL3BiL3NmL2V0aGVyZXVtL3R5cGUvdjI7cGJldGhiBnByb3RvMw", [file_google_protobuf_timestamp]);

/**
 * Block is the representation of the tracing of a block in the Ethereum
 * blockchain. A block is a collection of [TransactionTrace] that are grouped
 * together and processed as an atomic unit. Each [TransactionTrace] is composed
 * of a series of [Call] (a.k.a internal transactions) and there is also at
 * least one call per transaction a.k.a the root call which essentially has the
 * same parameters as the transaction itself (e.g. `from`, `to`, `gas`, `value`,
 * etc.).
 *
 * The exact tracing method used to build the block must be checked against
 * [DetailLevel] field. There is two levels of details available, `BASE` and
 * `EXTENDED`. The `BASE` level has been extracted using archive node RPC calls
 * and will contain only the block header, transaction receipts and event logs.
 * Refers to the Firehose service provider to know which blocks are offered on
 * each network.
 *
 * The `EXTENDED` level has been extracted using the Firehose tracer and all
 * fields are available in this Protobuf.
 *
 * The Ethereum block model is used across many chains which means that it
 * happen that certain fields are not available in one chain but are available
 * in another. Each field should be documented when necesssary if it's available
 * on a subset of chains.
 *
 * One major concept to get about the Block is the concept of 'ordinal'. The
 * ordinal is a number that is used to globally order every element of execution
 * that happened throughout the processing of the block like
 * [TransactionTracer], [Call], [Log], [BalanceChange], [StateChange], etc.
 * Element that have a start and end interval, [Transaction] and [Call], will
 * have two ordinals: `begin_ordinal` and `end_ordinal`. Element that are
 * executed as "point in time" [Log], [BalanceChange], [StateChange], etc. will
 * have only one ordinal named `ordinal`. If you take all of the message in the
 * Block that have an 'ordinal' field in an array and you sort each element
 * against the `ordinal` field, you will get the exact order of execution of
 * each element in the block.
 *
 * All the 'ordinal' fields in a block are globally unique for the given block,
 * it is **not** a chain-wide global ordering. Furthermore, caution must be take
 * with reverted elements due to execution failure. For anything attached to a
 * [Call] that has a `state_reverted` field set to `true`, the `ordinal` field
 * is not reliable and should not be used to order the element against other
 * elements in the block as those element might have 0 as the ordinal. Only
 * successful calls have a reliable `ordinal` field.
 *
 * @generated from message sf.ethereum.type.v2.Block
 */
export type Block = Message<"sf.ethereum.type.v2.Block"> & {
  /**
   * Hash is the block's hash.
   *
   * @generated from field: bytes hash = 2;
   */
  hash: Uint8Array;

  /**
   * Number is the block's height at which this block was mined.
   *
   * @generated from field: uint64 number = 3;
   */
  number: bigint;

  /**
   * Size is the size in bytes of the RLP encoding of the block according to Ethereum
   * rules.
   *
   * @generated from field: uint64 size = 4;
   */
  size: bigint;

  /**
   * Header contain's the block's header information like its parent hash, the merkel root hash
   * and all other information the form a block.
   *
   * @generated from field: sf.ethereum.type.v2.BlockHeader header = 5;
   */
  header?: BlockHeader;

  /**
   * Uncles represents block produced with a valid solution but were not actually choosen
   * as the canonical block for the given height so they are mostly "forked" blocks.
   *
   * If the Block has been produced using the Proof of Stake consensus algorithm, this
   * field will actually be always empty.
   *
   * @generated from field: repeated sf.ethereum.type.v2.BlockHeader uncles = 6;
   */
  uncles: BlockHeader[];

  /**
   * TransactionTraces hold the execute trace of all the transactions that were executed
   * in this block. In in there that you will find most of the Ethereum data model.
   *
   * They are ordered by the order of execution of the transaction in the block.
   *
   * @generated from field: repeated sf.ethereum.type.v2.TransactionTrace transaction_traces = 10;
   */
  transactionTraces: TransactionTrace[];

  /**
   * BalanceChanges here is the array of ETH transfer that happened at the block level
   * outside of the normal transaction flow of a block. The best example of this is mining
   * reward for the block mined, the transfer of ETH to the miner happens outside the normal
   * transaction flow of the chain and is recorded as a `BalanceChange` here since we cannot
   * attached it to any transaction.
   *
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: repeated sf.ethereum.type.v2.BalanceChange balance_changes = 11;
   */
  balanceChanges: BalanceChange[];

  /**
   * DetailLevel affects the data available in this block.
   *
   * ## DetailLevel_EXTENDED
   *
   * Describes the most complete block, with traces, balance changes, storage
   * changes. It is extracted during the execution of the block.
   *
   * ## DetailLevel_BASE
   *
   * Describes a block that contains only the block header, transaction receipts
   * and event logs: everything that can be extracted using the base JSON-RPC
   * interface
   * (https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods)
   * Furthermore, the eth_getTransactionReceipt call has been avoided because it
   * brings only minimal improvements at the cost of requiring an archive node
   * or a full node with complete transaction index.
   *
   * @generated from field: sf.ethereum.type.v2.Block.DetailLevel detail_level = 12;
   */
  detailLevel: Block_DetailLevel;

  /**
   * CodeChanges here is the array of smart code change that happened that happened at the block level
   * outside of the normal transaction flow of a block. Some Ethereum's fork like BSC and Polygon
   * has some capabilities to upgrade internal smart contracts used usually to track the validator
   * list.
   *
   * On hard fork, some procedure runs to upgrade the smart contract code to a new version. In those
   * network, a `CodeChange` for each modified smart contract on upgrade would be present here. Note
   * that this happen rarely, so the vast majority of block will have an empty list here.
   *
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: repeated sf.ethereum.type.v2.CodeChange code_changes = 20;
   */
  codeChanges: CodeChange[];

  /**
   * System calls are introduced in Cancun, along with blobs. They are executed outside of transactions but affect the state.
   *
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: repeated sf.ethereum.type.v2.Call system_calls = 21;
   */
  systemCalls: Call[];

  /**
   * Ver represents that data model version of the block, it is used internally by Firehose on Ethereum
   * as a validation that we are reading the correct version.
   *
   * @generated from field: int32 ver = 1;
   */
  ver: number;
};

/**
 * Describes the message sf.ethereum.type.v2.Block.
 * Use `create(BlockSchema)` to create a new message.
 */
export const BlockSchema: GenMessage<Block> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 0);

/**
 * @generated from enum sf.ethereum.type.v2.Block.DetailLevel
 */
export enum Block_DetailLevel {
  /**
   * @generated from enum value: DETAILLEVEL_EXTENDED = 0;
   */
  DETAILLEVEL_EXTENDED = 0,

  /**
   * DETAILLEVEL_TRACE = 1; // TBD
   *
   * @generated from enum value: DETAILLEVEL_BASE = 2;
   */
  DETAILLEVEL_BASE = 2,
}

/**
 * Describes the enum sf.ethereum.type.v2.Block.DetailLevel.
 */
export const Block_DetailLevelSchema: GenEnum<Block_DetailLevel> = /*@__PURE__*/
  enumDesc(file_sf_ethereum_type_v2_type, 0, 0);

/**
 * @generated from message sf.ethereum.type.v2.BlockHeader
 */
export type BlockHeader = Message<"sf.ethereum.type.v2.BlockHeader"> & {
  /**
   * @generated from field: bytes parent_hash = 1;
   */
  parentHash: Uint8Array;

  /**
   * Uncle hash of the block, some reference it as `sha3Uncles`, but `sha3`` is badly worded, so we prefer `uncle_hash`, also
   * referred as `ommers` in EIP specification.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field will actually be constant and set to `0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347`.
   *
   * @generated from field: bytes uncle_hash = 2;
   */
  uncleHash: Uint8Array;

  /**
   * @generated from field: bytes coinbase = 3;
   */
  coinbase: Uint8Array;

  /**
   * @generated from field: bytes state_root = 4;
   */
  stateRoot: Uint8Array;

  /**
   * @generated from field: bytes transactions_root = 5;
   */
  transactionsRoot: Uint8Array;

  /**
   * @generated from field: bytes receipt_root = 6;
   */
  receiptRoot: Uint8Array;

  /**
   * @generated from field: bytes logs_bloom = 7;
   */
  logsBloom: Uint8Array;

  /**
   * Difficulty is the difficulty of the Proof of Work algorithm that was required to compute a solution.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field will actually be constant and set to `0x00`.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt difficulty = 8;
   */
  difficulty?: BigInt;

  /**
   * TotalDifficulty is the sum of all previous blocks difficulty including this block difficulty.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field will actually be constant and set to the terminal total difficulty
   * that was required to transition to Proof of Stake algorithm, which varies per network. It is set to
   * 58 750 000 000 000 000 000 000 on Ethereum Mainnet and to 10 790 000 on Ethereum Testnet Goerli.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt total_difficulty = 17;
   */
  totalDifficulty?: BigInt;

  /**
   * @generated from field: uint64 number = 9;
   */
  number: bigint;

  /**
   * @generated from field: uint64 gas_limit = 10;
   */
  gasLimit: bigint;

  /**
   * @generated from field: uint64 gas_used = 11;
   */
  gasUsed: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 12;
   */
  timestamp?: Timestamp;

  /**
   * ExtraData is free-form bytes included in the block by the "miner". While on Yellow paper of
   * Ethereum this value is maxed to 32 bytes, other consensus algorithm like Clique and some other
   * forks are using bigger values to carry special consensus data.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field is strictly enforced to be <= 32 bytes.
   *
   * @generated from field: bytes extra_data = 13;
   */
  extraData: Uint8Array;

  /**
   * MixHash is used to prove, when combined with the `nonce` that sufficient amount of computation has been
   * achieved and that the solution found is valid.
   *
   * @generated from field: bytes mix_hash = 14;
   */
  mixHash: Uint8Array;

  /**
   * Nonce is used to prove, when combined with the `mix_hash` that sufficient amount of computation has been
   * achieved and that the solution found is valid.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field will actually be constant and set to `0`.
   *
   * @generated from field: uint64 nonce = 15;
   */
  nonce: bigint;

  /**
   * Hash is the hash of the block which is actually the computation:
   *
   *  Keccak256(rlp([
   *    parent_hash,
   *    uncle_hash,
   *    coinbase,
   *    state_root,
   *    transactions_root,
   *    receipt_root,
   *    logs_bloom,
   *    difficulty,
   *    number,
   *    gas_limit,
   *    gas_used,
   *    timestamp,
   *    extra_data,
   *    mix_hash,
   *    nonce,
   *    base_fee_per_gas (to be included only if London fork is active)
   *    withdrawals_root (to be included only if Shangai fork is active)
   *    blob_gas_used (to be included only if Cancun fork is active)
   *    excess_blob_gas (to be included only if Cancun fork is active)
   *    parent_beacon_root (to be included only if Cancun fork is active)
   *  ]))
   *
   *
   * @generated from field: bytes hash = 16;
   */
  hash: Uint8Array;

  /**
   * Base fee per gas according to EIP-1559 (e.g. London Fork) rules, only set if London is present/active on the chain.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt base_fee_per_gas = 18;
   */
  baseFeePerGas?: BigInt;

  /**
   * Withdrawals root hash according to EIP-4895 (e.g. Shangai Fork) rules, only set if Shangai is present/active on the chain.
   *
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: bytes withdrawals_root = 19;
   */
  withdrawalsRoot: Uint8Array;

  /**
   * TxDependency is list of transaction indexes that are dependent on each other in the block
   * header. This is metadata only that was used by the internal Polygon parallel execution engine.
   *
   * This field was available in a few versions on Polygon Mainnet and Polygon Mumbai chains. It was actually
   * removed and is not populated anymore. It's now embeded in the `extraData` field, refer to Polygon source
   * code to determine how to extract it if you need it.
   *
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: sf.ethereum.type.v2.Uint64NestedArray tx_dependency = 20;
   */
  txDependency?: Uint64NestedArray;

  /**
   * BlobGasUsed was added by EIP-4844 and is ignored in legacy headers.
   *
   * @generated from field: optional uint64 blob_gas_used = 22;
   */
  blobGasUsed?: bigint;

  /**
   * ExcessBlobGas was added by EIP-4844 and is ignored in legacy headers.
   *
   * @generated from field: optional uint64 excess_blob_gas = 23;
   */
  excessBlobGas?: bigint;

  /**
   * ParentBeaconRoot was added by EIP-4788 and is ignored in legacy headers.
   *
   * @generated from field: bytes parent_beacon_root = 24;
   */
  parentBeaconRoot: Uint8Array;

  /**
   * RequestsHash was added by EIP-7685 and is ignored in legacy headers.
   *
   * @generated from field: bytes requests_hash = 25;
   */
  requestsHash: Uint8Array;
};

/**
 * Describes the message sf.ethereum.type.v2.BlockHeader.
 * Use `create(BlockHeaderSchema)` to create a new message.
 */
export const BlockHeaderSchema: GenMessage<BlockHeader> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 1);

/**
 * @generated from message sf.ethereum.type.v2.Uint64NestedArray
 */
export type Uint64NestedArray = Message<"sf.ethereum.type.v2.Uint64NestedArray"> & {
  /**
   * @generated from field: repeated sf.ethereum.type.v2.Uint64Array val = 1;
   */
  val: Uint64Array[];
};

/**
 * Describes the message sf.ethereum.type.v2.Uint64NestedArray.
 * Use `create(Uint64NestedArraySchema)` to create a new message.
 */
export const Uint64NestedArraySchema: GenMessage<Uint64NestedArray> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 2);

/**
 * @generated from message sf.ethereum.type.v2.Uint64Array
 */
export type Uint64Array = Message<"sf.ethereum.type.v2.Uint64Array"> & {
  /**
   * @generated from field: repeated uint64 val = 1;
   */
  val: bigint[];
};

/**
 * Describes the message sf.ethereum.type.v2.Uint64Array.
 * Use `create(Uint64ArraySchema)` to create a new message.
 */
export const Uint64ArraySchema: GenMessage<Uint64Array> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 3);

/**
 * @generated from message sf.ethereum.type.v2.BigInt
 */
export type BigInt = Message<"sf.ethereum.type.v2.BigInt"> & {
  /**
   * @generated from field: bytes bytes = 1;
   */
  bytes: Uint8Array;
};

/**
 * Describes the message sf.ethereum.type.v2.BigInt.
 * Use `create(BigIntSchema)` to create a new message.
 */
export const BigIntSchema: GenMessage<BigInt> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 4);

/**
 * TransactionTrace is full trace of execution of the transaction when the
 * it actually executed on chain.
 *
 * It contains all the transaction details like `from`, `to`, `gas`, etc.
 * as well as all the internal calls that were made during the transaction.
 *
 * The `calls` vector contains Call objects which have balance changes, events
 * storage changes, etc.
 *
 * If ordering is important between elements, almost each message like `Log`,
 * `Call`, `StorageChange`, etc. have an ordinal field that is represents "execution"
 * order of the said element against all other elements in this block.
 *
 * Due to how the call tree works doing "naively", looping through all calls then
 * through a Call's element like `logs` while not yielding the elements in the order
 * they were executed on chain. A log in call could have been done before or after
 * another in another call depending on the actual call tree.
 *
 * The `calls` are ordered by creation order and the call tree can be re-computing
 * using fields found in `Call` object (parent/child relationship).
 *
 * Another important thing to note is that even if a transaction succeed, some calls
 * within it could have been reverted internally, if this is important to you, you must
 * check the field `state_reverted` on the `Call` to determine if it was fully committed
 * to the chain or not.
 *
 * @generated from message sf.ethereum.type.v2.TransactionTrace
 */
export type TransactionTrace = Message<"sf.ethereum.type.v2.TransactionTrace"> & {
  /**
   * consensus
   *
   * @generated from field: bytes to = 1;
   */
  to: Uint8Array;

  /**
   * @generated from field: uint64 nonce = 2;
   */
  nonce: bigint;

  /**
   * GasPrice represents the effective price that has been paid for each gas unit of this transaction. Over time, the
   * Ethereum rules changes regarding GasPrice field here. Before London fork, the GasPrice was always set to the
   * fixed gas price. After London fork, this value has different meaning depending on the transaction type (see `Type` field).
   *
   * In cases where `TransactionTrace.Type == TRX_TYPE_LEGACY || TRX_TYPE_ACCESS_LIST`, then GasPrice has the same meaning
   * as before the London fork.
   *
   * In cases where `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE`, then GasPrice is the effective gas price paid
   * for the transaction which is equals to `BlockHeader.BaseFeePerGas + TransactionTrace.`
   *
   * @generated from field: sf.ethereum.type.v2.BigInt gas_price = 3;
   */
  gasPrice?: BigInt;

  /**
   * GasLimit is the maximum of gas unit the sender of the transaction is willing to consume when perform the EVM
   * execution of the whole transaction
   *
   * @generated from field: uint64 gas_limit = 4;
   */
  gasLimit: bigint;

  /**
   * Value is the amount of Ether transferred as part of this transaction.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt value = 5;
   */
  value?: BigInt;

  /**
   * Input data the transaction will receive for execution of EVM.
   *
   * @generated from field: bytes input = 6;
   */
  input: Uint8Array;

  /**
   * V is the recovery ID value for the signature Y point.
   *
   * @generated from field: bytes v = 7;
   */
  v: Uint8Array;

  /**
   * R is the signature's X point on the elliptic curve (32 bytes).
   *
   * @generated from field: bytes r = 8;
   */
  r: Uint8Array;

  /**
   * S is the signature's Y point on the elliptic curve (32 bytes).
   *
   * @generated from field: bytes s = 9;
   */
  s: Uint8Array;

  /**
   * GasUsed is the total amount of gas unit used for the whole execution of the transaction.
   *
   * @generated from field: uint64 gas_used = 10;
   */
  gasUsed: bigint;

  /**
   * Type represents the Ethereum transaction type, available only since EIP-2718 & EIP-2930 activation which happened on Berlin fork.
   * The value is always set even for transaction before Berlin fork because those before the fork are still legacy transactions.
   *
   * @generated from field: sf.ethereum.type.v2.TransactionTrace.Type type = 12;
   */
  type: TransactionTrace_Type;

  /**
   * AcccessList represents the storage access this transaction has agreed to do in which case those storage
   * access cost less gas unit per access.
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_ACCESS_LIST || TRX_TYPE_DYNAMIC_FEE` which
   * is possible only if Berlin (TRX_TYPE_ACCESS_LIST) nor London (TRX_TYPE_DYNAMIC_FEE) fork are active on the chain.
   *
   * @generated from field: repeated sf.ethereum.type.v2.AccessTuple access_list = 14;
   */
  accessList: AccessTuple[];

  /**
   * MaxFeePerGas is the maximum fee per gas the user is willing to pay for the transaction gas used.
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE` which is possible only
   * if Londong fork is active on the chain.
   *
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: sf.ethereum.type.v2.BigInt max_fee_per_gas = 11;
   */
  maxFeePerGas?: BigInt;

  /**
   * MaxPriorityFeePerGas is priority fee per gas the user to pay in extra to the miner on top of the block's
   * base fee.
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE` which is possible only
   * if London fork is active on the chain.
   *
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: sf.ethereum.type.v2.BigInt max_priority_fee_per_gas = 13;
   */
  maxPriorityFeePerGas?: BigInt;

  /**
   * meta
   *
   * @generated from field: uint32 index = 20;
   */
  index: number;

  /**
   * @generated from field: bytes hash = 21;
   */
  hash: Uint8Array;

  /**
   * @generated from field: bytes from = 22;
   */
  from: Uint8Array;

  /**
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: bytes return_data = 23;
   */
  returnData: Uint8Array;

  /**
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: bytes public_key = 24;
   */
  publicKey: Uint8Array;

  /**
   * The block's global ordinal when the transaction started executing, refer to
   * [Block] documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 begin_ordinal = 25;
   */
  beginOrdinal: bigint;

  /**
   * The block's global ordinal when the transaction finished executing, refer to
   * [Block] documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 end_ordinal = 26;
   */
  endOrdinal: bigint;

  /**
   * TransactionTraceStatus is the status of the transaction execution and will let you know if the transaction
   * was successful or not.
   *
   * ## Explanation relevant only for blocks with `DetailLevel: EXTENDED`
   *
   * A successful transaction has been recorded to the blockchain's state for calls in it that were successful.
   * This means it's possible only a subset of the calls were properly recorded, refer to [calls[].state_reverted] field
   * to determine which calls were reverted.
   *
   * A quirks of the Ethereum protocol is that a transaction `FAILED` or `REVERTED` still affects the blockchain's
   * state for **some** of the state changes. Indeed, in those cases, the transactions fees are still paid to the miner
   * which means there is a balance change for the transaction's emitter (e.g. `from`) to pay the gas fees, an optional
   * balance change for gas refunded to the transaction's emitter (e.g. `from`) and a balance change for the miner who
   * received the transaction fees. There is also a nonce change for the transaction's emitter (e.g. `from`).
   *
   * This means that to properly record the state changes for a transaction, you need to conditionally procees the
   * transaction's status.
   *
   * For a `SUCCEEDED` transaction, you iterate over the `calls` array and record the state changes for each call for
   * which `state_reverted == false` (if a transaction succeeded, the call at #0 will always `state_reverted == false`
   * because it aligns with the transaction).
   *
   * For a `FAILED` or `REVERTED` transaction, you iterate over the root call (e.g. at #0, will always exist) for
   * balance changes you process those where `reason` is either `REASON_GAS_BUY`, `REASON_GAS_REFUND` or
   * `REASON_REWARD_TRANSACTION_FEE` and for nonce change, still on the root call, you pick the nonce change which the
   * smallest ordinal (if more than one).
   *
   * @generated from field: sf.ethereum.type.v2.TransactionTraceStatus status = 30;
   */
  status: TransactionTraceStatus;

  /**
   * @generated from field: sf.ethereum.type.v2.TransactionReceipt receipt = 31;
   */
  receipt?: TransactionReceipt;

  /**
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: repeated sf.ethereum.type.v2.Call calls = 32;
   */
  calls: Call[];

  /**
   * BlobGas is the amount of gas the transaction is going to pay for the blobs, this is a computed value
   * equivalent to `self.blob_gas_fee_cap * len(self.blob_hashes)` and provided in the model for convenience.
   *
   * This is specified by https://eips.ethereum.org/EIPS/eip-4844
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
   * if Cancun fork is active on the chain.
   *
   * @generated from field: optional uint64 blob_gas = 33;
   */
  blobGas?: bigint;

  /**
   * BlobGasFeeCap is the maximum fee per data gas the user is willing to pay for the data gas used.
   *
   * This is specified by https://eips.ethereum.org/EIPS/eip-4844
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
   * if Cancun fork is active on the chain.
   *
   * @generated from field: optional sf.ethereum.type.v2.BigInt blob_gas_fee_cap = 34;
   */
  blobGasFeeCap?: BigInt;

  /**
   * BlobHashes field represents a list of hash outputs from 'kzg_to_versioned_hash' which
   * essentially is a version byte + the sha256 hash of the blob commitment (e.g.
   * `BLOB_COMMITMENT_VERSION_KZG + sha256(commitment)[1:]`.
   *
   * This is specified by https://eips.ethereum.org/EIPS/eip-4844
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
   * if Cancun fork is active on the chain.
   *
   * @generated from field: repeated bytes blob_hashes = 35;
   */
  blobHashes: Uint8Array[];
};

/**
 * Describes the message sf.ethereum.type.v2.TransactionTrace.
 * Use `create(TransactionTraceSchema)` to create a new message.
 */
export const TransactionTraceSchema: GenMessage<TransactionTrace> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 5);

/**
 * @generated from enum sf.ethereum.type.v2.TransactionTrace.Type
 */
export enum TransactionTrace_Type {
  /**
   * All transactions that ever existed prior Berlin fork before EIP-2718 was implemented.
   *
   * @generated from enum value: TRX_TYPE_LEGACY = 0;
   */
  TRX_TYPE_LEGACY = 0,

  /**
   * Transaction that specicy an access list of contract/storage_keys that is going to be used
   * in this transaction.
   *
   * Added in Berlin fork (EIP-2930).
   *
   * @generated from enum value: TRX_TYPE_ACCESS_LIST = 1;
   */
  TRX_TYPE_ACCESS_LIST = 1,

  /**
   * Transaction that specifis an access list just like TRX_TYPE_ACCESS_LIST but in addition defines the
   * max base gas gee and max priority gas fee to pay for this transaction. Transaction's of those type are
   * executed against EIP-1559 rules which dictates a dynamic gas cost based on the congestion of the network.
   *
   * @generated from enum value: TRX_TYPE_DYNAMIC_FEE = 2;
   */
  TRX_TYPE_DYNAMIC_FEE = 2,

  /**
   * Transaction which contain a large amount of data that cannot be accessed by EVM execution, but whose commitment
   * can be accessed. The format is intended to be fully compatible with the format that will be used in full sharding.
   *
   * Transaction that defines specifis an access list just like TRX_TYPE_ACCESS_LIST and enables dynamic fee just like
   * TRX_TYPE_DYNAMIC_FEE but in addition defines the fields 'max_fee_per_data_gas' of type 'uint256' and the fields
   * 'blob_versioned_hashes' field represents a list of hash outputs from 'kzg_to_versioned_hash'.
   *
   * Activated in Dencun
   *
   * @generated from enum value: TRX_TYPE_BLOB = 3;
   */
  TRX_TYPE_BLOB = 3,

  /**
   * Arbitrum-specific transactions
   *
   * @generated from enum value: TRX_TYPE_ARBITRUM_DEPOSIT = 100;
   */
  TRX_TYPE_ARBITRUM_DEPOSIT = 100,

  /**
   * @generated from enum value: TRX_TYPE_ARBITRUM_UNSIGNED = 101;
   */
  TRX_TYPE_ARBITRUM_UNSIGNED = 101,

  /**
   * @generated from enum value: TRX_TYPE_ARBITRUM_CONTRACT = 102;
   */
  TRX_TYPE_ARBITRUM_CONTRACT = 102,

  /**
   * @generated from enum value: TRX_TYPE_ARBITRUM_RETRY = 104;
   */
  TRX_TYPE_ARBITRUM_RETRY = 104,

  /**
   * @generated from enum value: TRX_TYPE_ARBITRUM_SUBMIT_RETRYABLE = 105;
   */
  TRX_TYPE_ARBITRUM_SUBMIT_RETRYABLE = 105,

  /**
   * @generated from enum value: TRX_TYPE_ARBITRUM_INTERNAL = 106;
   */
  TRX_TYPE_ARBITRUM_INTERNAL = 106,

  /**
   * @generated from enum value: TRX_TYPE_ARBITRUM_LEGACY = 120;
   */
  TRX_TYPE_ARBITRUM_LEGACY = 120,

  /**
   * OPTIMISM-specific transactions
   *
   * @generated from enum value: TRX_TYPE_OPTIMISM_DEPOSIT = 126;
   */
  TRX_TYPE_OPTIMISM_DEPOSIT = 126,
}

/**
 * Describes the enum sf.ethereum.type.v2.TransactionTrace.Type.
 */
export const TransactionTrace_TypeSchema: GenEnum<TransactionTrace_Type> = /*@__PURE__*/
  enumDesc(file_sf_ethereum_type_v2_type, 5, 0);

/**
 * AccessTuple represents a list of storage keys for a given contract's address and is used
 * for AccessList construction.
 *
 * @generated from message sf.ethereum.type.v2.AccessTuple
 */
export type AccessTuple = Message<"sf.ethereum.type.v2.AccessTuple"> & {
  /**
   * @generated from field: bytes address = 1;
   */
  address: Uint8Array;

  /**
   * @generated from field: repeated bytes storage_keys = 2;
   */
  storageKeys: Uint8Array[];
};

/**
 * Describes the message sf.ethereum.type.v2.AccessTuple.
 * Use `create(AccessTupleSchema)` to create a new message.
 */
export const AccessTupleSchema: GenMessage<AccessTuple> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 6);

/**
 * @generated from message sf.ethereum.type.v2.TransactionReceipt
 */
export type TransactionReceipt = Message<"sf.ethereum.type.v2.TransactionReceipt"> & {
  /**
   * State root is an intermediate state_root hash, computed in-between transactions to make
   * **sure** you could build a proof and point to state in the middle of a block. Geth client
   * uses `PostState + root + PostStateOrStatus`` while Parity used `status_code, root...`` this piles
   * hardforks, see (read the EIPs first):
   * - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-658.md
   *
   * Moreover, the notion of `Outcome`` in parity, which segregates the two concepts, which are
   * stored in the same field `status_code`` can be computed based on such a hack of the `state_root`
   * field, following `EIP-658`.
   *
   * Before Byzantinium hard fork, this field is always empty.
   *
   * @generated from field: bytes state_root = 1;
   */
  stateRoot: Uint8Array;

  /**
   * @generated from field: uint64 cumulative_gas_used = 2;
   */
  cumulativeGasUsed: bigint;

  /**
   * @generated from field: bytes logs_bloom = 3;
   */
  logsBloom: Uint8Array;

  /**
   * @generated from field: repeated sf.ethereum.type.v2.Log logs = 4;
   */
  logs: Log[];

  /**
   * BlobGasUsed is the amount of blob gas that has been used within this transaction. At time
   * of writing, this is equal to `self.blob_gas_fee_cap * len(self.blob_hashes)`.
   *
   * This is specified by https://eips.ethereum.org/EIPS/eip-4844
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
   * if Cancun fork is active on the chain.
   *
   * @generated from field: optional uint64 blob_gas_used = 5;
   */
  blobGasUsed?: bigint;

  /**
   * BlobGasPrice is the amount to pay per blob item in the transaction.
   *
   * This is specified by https://eips.ethereum.org/EIPS/eip-4844
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_BLOB` which is possible only
   * if Cancun fork is active on the chain.
   *
   * @generated from field: optional sf.ethereum.type.v2.BigInt blob_gas_price = 6;
   */
  blobGasPrice?: BigInt;
};

/**
 * Describes the message sf.ethereum.type.v2.TransactionReceipt.
 * Use `create(TransactionReceiptSchema)` to create a new message.
 */
export const TransactionReceiptSchema: GenMessage<TransactionReceipt> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 7);

/**
 * @generated from message sf.ethereum.type.v2.Log
 */
export type Log = Message<"sf.ethereum.type.v2.Log"> & {
  /**
   * @generated from field: bytes address = 1;
   */
  address: Uint8Array;

  /**
   * @generated from field: repeated bytes topics = 2;
   */
  topics: Uint8Array[];

  /**
   * @generated from field: bytes data = 3;
   */
  data: Uint8Array;

  /**
   * Index is the index of the log relative to the transaction. This index
   * is always populated regardless of the state revertion of the the call
   * that emitted this log.
   *
   * Only available in DetailLevel: EXTENDED
   *
   * @generated from field: uint32 index = 4;
   */
  index: number;

  /**
   * BlockIndex represents the index of the log relative to the Block.
   *
   * An **important** notice is that this field will be 0 when the call
   * that emitted the log has been reverted by the chain.
   *
   * Currently, there is two locations where a Log can be obtained:
   * - block.transaction_traces[].receipt.logs[]
   * - block.transaction_traces[].calls[].logs[]
   *
   * In the `receipt` case, the logs will be populated only when the call
   * that emitted them has not been reverted by the chain and when in this
   * position, the `blockIndex` is always populated correctly.
   *
   * In the case of `calls` case, for `call` where `stateReverted == true`,
   * the `blockIndex` value will always be 0.
   *
   * @generated from field: uint32 blockIndex = 6;
   */
  blockIndex: number;

  /**
   * The block's global ordinal when the log was recorded, refer to [Block]
   * documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 ordinal = 7;
   */
  ordinal: bigint;
};

/**
 * Describes the message sf.ethereum.type.v2.Log.
 * Use `create(LogSchema)` to create a new message.
 */
export const LogSchema: GenMessage<Log> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 8);

/**
 * @generated from message sf.ethereum.type.v2.Call
 */
export type Call = Message<"sf.ethereum.type.v2.Call"> & {
  /**
   * @generated from field: uint32 index = 1;
   */
  index: number;

  /**
   * @generated from field: uint32 parent_index = 2;
   */
  parentIndex: number;

  /**
   * @generated from field: uint32 depth = 3;
   */
  depth: number;

  /**
   * @generated from field: sf.ethereum.type.v2.CallType call_type = 4;
   */
  callType: CallType;

  /**
   * @generated from field: bytes caller = 5;
   */
  caller: Uint8Array;

  /**
   * @generated from field: bytes address = 6;
   */
  address: Uint8Array;

  /**
   * @generated from field: sf.ethereum.type.v2.BigInt value = 7;
   */
  value?: BigInt;

  /**
   * @generated from field: uint64 gas_limit = 8;
   */
  gasLimit: bigint;

  /**
   * @generated from field: uint64 gas_consumed = 9;
   */
  gasConsumed: bigint;

  /**
   * @generated from field: bytes return_data = 13;
   */
  returnData: Uint8Array;

  /**
   * @generated from field: bytes input = 14;
   */
  input: Uint8Array;

  /**
   * @generated from field: bool executed_code = 15;
   */
  executedCode: boolean;

  /**
   * @generated from field: bool suicide = 16;
   */
  suicide: boolean;

  /**
   * hex representation of the hash -> preimage 
   *
   * @generated from field: map<string, string> keccak_preimages = 20;
   */
  keccakPreimages: { [key: string]: string };

  /**
   * @generated from field: repeated sf.ethereum.type.v2.StorageChange storage_changes = 21;
   */
  storageChanges: StorageChange[];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.BalanceChange balance_changes = 22;
   */
  balanceChanges: BalanceChange[];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.NonceChange nonce_changes = 24;
   */
  nonceChanges: NonceChange[];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.Log logs = 25;
   */
  logs: Log[];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.CodeChange code_changes = 26;
   */
  codeChanges: CodeChange[];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.GasChange gas_changes = 28;
   */
  gasChanges: GasChange[];

  /**
   * In Ethereum, a call can be either:
   * - Successfull, execution passes without any problem encountered
   * - Failed, execution failed, and remaining gas should be consumed
   * - Reverted, execution failed, but only gas consumed so far is billed, remaining gas is refunded
   *
   * When a call is either `failed` or `reverted`, the `status_failed` field
   * below is set to `true`. If the status is `reverted`, then both `status_failed`
   * and `status_reverted` are going to be set to `true`.
   *
   * @generated from field: bool status_failed = 10;
   */
  statusFailed: boolean;

  /**
   * @generated from field: bool status_reverted = 12;
   */
  statusReverted: boolean;

  /**
   * Populated when a call either failed or reverted, so when `status_failed == true`,
   * see above for details about those flags.
   *
   * @generated from field: string failure_reason = 11;
   */
  failureReason: string;

  /**
   * This field represents wheter or not the state changes performed
   * by this call were correctly recorded by the blockchain.
   *
   * On Ethereum, a transaction can record state changes even if some
   * of its inner nested calls failed. This is problematic however since
   * a call will invalidate all its state changes as well as all state
   * changes performed by its child call. This means that even if a call
   * has a status of `SUCCESS`, the chain might have reverted all the state
   * changes it performed.
   *
   * ```text
   *   Trx 1
   *    Call #1 <Failed>
   *      Call #2 <Execution Success>
   *      Call #3 <Execution Success>
   *      |--- Failure here
   *    Call #4
   * ```
   *
   * In the transaction above, while Call #2 and Call #3 would have the
   * status `EXECUTED`.
   *
   * If you check all calls and check only `state_reverted` flag, you might be missing
   * some balance changes and nonce changes. This is because when a full transaction fails
   * in ethereum (e.g. `calls.all(x.state_reverted == true)`), there is still the transaction
   * fee that are recorded to the chain.
   *
   * Refer to [TransactionTrace#status] field for more details about the handling you must
   * perform.
   *
   * @generated from field: bool state_reverted = 30;
   */
  stateReverted: boolean;

  /**
   * The block's global ordinal when the call started executing, refer to
   * [Block] documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 begin_ordinal = 31;
   */
  beginOrdinal: bigint;

  /**
   * The block's global ordinal when the call finished executing, refer to
   * [Block] documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 end_ordinal = 32;
   */
  endOrdinal: bigint;

  /**
   * @generated from field: repeated sf.ethereum.type.v2.AccountCreation account_creations = 33;
   */
  accountCreations: AccountCreation[];
};

/**
 * Describes the message sf.ethereum.type.v2.Call.
 * Use `create(CallSchema)` to create a new message.
 */
export const CallSchema: GenMessage<Call> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 9);

/**
 * @generated from message sf.ethereum.type.v2.StorageChange
 */
export type StorageChange = Message<"sf.ethereum.type.v2.StorageChange"> & {
  /**
   * @generated from field: bytes address = 1;
   */
  address: Uint8Array;

  /**
   * @generated from field: bytes key = 2;
   */
  key: Uint8Array;

  /**
   * @generated from field: bytes old_value = 3;
   */
  oldValue: Uint8Array;

  /**
   * @generated from field: bytes new_value = 4;
   */
  newValue: Uint8Array;

  /**
   * The block's global ordinal when the storage change was recorded, refer to [Block]
   * documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 ordinal = 5;
   */
  ordinal: bigint;
};

/**
 * Describes the message sf.ethereum.type.v2.StorageChange.
 * Use `create(StorageChangeSchema)` to create a new message.
 */
export const StorageChangeSchema: GenMessage<StorageChange> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 10);

/**
 * @generated from message sf.ethereum.type.v2.BalanceChange
 */
export type BalanceChange = Message<"sf.ethereum.type.v2.BalanceChange"> & {
  /**
   * Address is the address of the account that has changed balance.
   *
   * @generated from field: bytes address = 1;
   */
  address: Uint8Array;

  /**
   * OldValue is the balance of the address before the change. This value
   * can be **nil/null/None** if there was no previous balance for the address.
   * It is safe in those case(s) to consider the balance as being 0.
   *
   * If you consume this from a Substreams, you can safely use:
   *
   * ```ignore
   *     let old_value = old_value.unwrap_or_default();
   * ```
   *
   * @generated from field: sf.ethereum.type.v2.BigInt old_value = 2;
   */
  oldValue?: BigInt;

  /**
   * NewValue is the balance of the address after the change. This value
   * can be **nil/null/None** if there was no previous balance for the address
   * after the change. It is safe in those case(s) to consider the balance as being
   * 0.
   *
   * If you consume this from a Substreams, you can safely use:
   *
   * ```ignore
   *     let new_value = new_value.unwrap_or_default();
   * ```
   *
   * @generated from field: sf.ethereum.type.v2.BigInt new_value = 3;
   */
  newValue?: BigInt;

  /**
   * Reason is the reason why the balance has changed. This is useful to determine
   * why the balance has changed and what is the context of the change.
   *
   * @generated from field: sf.ethereum.type.v2.BalanceChange.Reason reason = 4;
   */
  reason: BalanceChange_Reason;

  /**
   * The block's global ordinal when the balance change was recorded, refer to [Block]
   * documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 ordinal = 5;
   */
  ordinal: bigint;
};

/**
 * Describes the message sf.ethereum.type.v2.BalanceChange.
 * Use `create(BalanceChangeSchema)` to create a new message.
 */
export const BalanceChangeSchema: GenMessage<BalanceChange> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 11);

/**
 * Obtain all balanche change reasons under deep mind repository:
 *
 * ```shell
 * ack -ho 'BalanceChangeReason\(".*"\)' | grep -Eo '".*"' | sort | uniq
 * ```
 *
 * @generated from enum sf.ethereum.type.v2.BalanceChange.Reason
 */
export enum BalanceChange_Reason {
  /**
   * @generated from enum value: REASON_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: REASON_REWARD_MINE_UNCLE = 1;
   */
  REWARD_MINE_UNCLE = 1,

  /**
   * @generated from enum value: REASON_REWARD_MINE_BLOCK = 2;
   */
  REWARD_MINE_BLOCK = 2,

  /**
   * @generated from enum value: REASON_DAO_REFUND_CONTRACT = 3;
   */
  DAO_REFUND_CONTRACT = 3,

  /**
   * @generated from enum value: REASON_DAO_ADJUST_BALANCE = 4;
   */
  DAO_ADJUST_BALANCE = 4,

  /**
   * @generated from enum value: REASON_TRANSFER = 5;
   */
  TRANSFER = 5,

  /**
   * @generated from enum value: REASON_GENESIS_BALANCE = 6;
   */
  GENESIS_BALANCE = 6,

  /**
   * @generated from enum value: REASON_GAS_BUY = 7;
   */
  GAS_BUY = 7,

  /**
   * @generated from enum value: REASON_REWARD_TRANSACTION_FEE = 8;
   */
  REWARD_TRANSACTION_FEE = 8,

  /**
   * @generated from enum value: REASON_REWARD_FEE_RESET = 14;
   */
  REWARD_FEE_RESET = 14,

  /**
   * @generated from enum value: REASON_GAS_REFUND = 9;
   */
  GAS_REFUND = 9,

  /**
   * @generated from enum value: REASON_TOUCH_ACCOUNT = 10;
   */
  TOUCH_ACCOUNT = 10,

  /**
   * @generated from enum value: REASON_SUICIDE_REFUND = 11;
   */
  SUICIDE_REFUND = 11,

  /**
   * @generated from enum value: REASON_SUICIDE_WITHDRAW = 13;
   */
  SUICIDE_WITHDRAW = 13,

  /**
   * @generated from enum value: REASON_CALL_BALANCE_OVERRIDE = 12;
   */
  CALL_BALANCE_OVERRIDE = 12,

  /**
   * Used on chain(s) where some Ether burning happens
   *
   * @generated from enum value: REASON_BURN = 15;
   */
  BURN = 15,

  /**
   * @generated from enum value: REASON_WITHDRAWAL = 16;
   */
  WITHDRAWAL = 16,

  /**
   * Rewards for Blob processing on BNB chain added in Tycho hard-fork, refers
   * to BNB documentation to check the timestamp at which it was activated.
   *
   * @generated from enum value: REASON_REWARD_BLOB_FEE = 17;
   */
  REWARD_BLOB_FEE = 17,

  /**
   * USE on optimism chan
   *
   * @generated from enum value: REASON_INCREASE_MINT = 18;
   */
  INCREASE_MINT = 18,
}

/**
 * Describes the enum sf.ethereum.type.v2.BalanceChange.Reason.
 */
export const BalanceChange_ReasonSchema: GenEnum<BalanceChange_Reason> = /*@__PURE__*/
  enumDesc(file_sf_ethereum_type_v2_type, 11, 0);

/**
 * @generated from message sf.ethereum.type.v2.NonceChange
 */
export type NonceChange = Message<"sf.ethereum.type.v2.NonceChange"> & {
  /**
   * @generated from field: bytes address = 1;
   */
  address: Uint8Array;

  /**
   * @generated from field: uint64 old_value = 2;
   */
  oldValue: bigint;

  /**
   * @generated from field: uint64 new_value = 3;
   */
  newValue: bigint;

  /**
   * The block's global ordinal when the nonce change was recorded, refer to [Block]
   * documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 ordinal = 4;
   */
  ordinal: bigint;
};

/**
 * Describes the message sf.ethereum.type.v2.NonceChange.
 * Use `create(NonceChangeSchema)` to create a new message.
 */
export const NonceChangeSchema: GenMessage<NonceChange> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 12);

/**
 * @generated from message sf.ethereum.type.v2.AccountCreation
 */
export type AccountCreation = Message<"sf.ethereum.type.v2.AccountCreation"> & {
  /**
   * @generated from field: bytes account = 1;
   */
  account: Uint8Array;

  /**
   * The block's global ordinal when the account creation was recorded, refer to [Block]
   * documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 ordinal = 2;
   */
  ordinal: bigint;
};

/**
 * Describes the message sf.ethereum.type.v2.AccountCreation.
 * Use `create(AccountCreationSchema)` to create a new message.
 */
export const AccountCreationSchema: GenMessage<AccountCreation> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 13);

/**
 * @generated from message sf.ethereum.type.v2.CodeChange
 */
export type CodeChange = Message<"sf.ethereum.type.v2.CodeChange"> & {
  /**
   * @generated from field: bytes address = 1;
   */
  address: Uint8Array;

  /**
   * @generated from field: bytes old_hash = 2;
   */
  oldHash: Uint8Array;

  /**
   * @generated from field: bytes old_code = 3;
   */
  oldCode: Uint8Array;

  /**
   * @generated from field: bytes new_hash = 4;
   */
  newHash: Uint8Array;

  /**
   * @generated from field: bytes new_code = 5;
   */
  newCode: Uint8Array;

  /**
   * The block's global ordinal when the code change was recorded, refer to [Block]
   * documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 ordinal = 6;
   */
  ordinal: bigint;
};

/**
 * Describes the message sf.ethereum.type.v2.CodeChange.
 * Use `create(CodeChangeSchema)` to create a new message.
 */
export const CodeChangeSchema: GenMessage<CodeChange> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 14);

/**
 * The gas change model represents the reason why some gas cost has occurred.
 * The gas is computed per actual op codes. Doing them completely might prove
 * overwhelming in most cases.
 *
 * Hence, we only index some of them, those that are costy like all the calls
 * one, log events, return data, etc.
 *
 * @generated from message sf.ethereum.type.v2.GasChange
 */
export type GasChange = Message<"sf.ethereum.type.v2.GasChange"> & {
  /**
   * @generated from field: uint64 old_value = 1;
   */
  oldValue: bigint;

  /**
   * @generated from field: uint64 new_value = 2;
   */
  newValue: bigint;

  /**
   * @generated from field: sf.ethereum.type.v2.GasChange.Reason reason = 3;
   */
  reason: GasChange_Reason;

  /**
   * The block's global ordinal when the gas change was recorded, refer to [Block]
   * documentation for further information about ordinals and total ordering.
   *
   * @generated from field: uint64 ordinal = 4;
   */
  ordinal: bigint;
};

/**
 * Describes the message sf.ethereum.type.v2.GasChange.
 * Use `create(GasChangeSchema)` to create a new message.
 */
export const GasChangeSchema: GenMessage<GasChange> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 15);

/**
 * Obtain all gas change reasons under deep mind repository:
 *
 * ```shell
 * ack -ho 'GasChangeReason\(".*"\)' | grep -Eo '".*"' | sort | uniq
 * ```
 *
 * @generated from enum sf.ethereum.type.v2.GasChange.Reason
 */
export enum GasChange_Reason {
  /**
   * @generated from enum value: REASON_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * REASON_CALL is the amount of gas that will be charged for a 'CALL' opcode executed by the EVM
   *
   * @generated from enum value: REASON_CALL = 1;
   */
  CALL = 1,

  /**
   * REASON_CALL_CODE is the amount of gas that will be charged for a 'CALLCODE' opcode executed by the EVM
   *
   * @generated from enum value: REASON_CALL_CODE = 2;
   */
  CALL_CODE = 2,

  /**
   * REASON_CALL_DATA_COPY is the amount of gas that will be charged for a 'CALLDATACOPY' opcode executed by the EVM
   *
   * @generated from enum value: REASON_CALL_DATA_COPY = 3;
   */
  CALL_DATA_COPY = 3,

  /**
   * REASON_CODE_COPY is the amount of gas that will be charged for a 'CALLDATACOPY' opcode executed by the EVM
   *
   * @generated from enum value: REASON_CODE_COPY = 4;
   */
  CODE_COPY = 4,

  /**
   * REASON_CODE_STORAGE is the amount of gas that will be charged for code storage
   *
   * @generated from enum value: REASON_CODE_STORAGE = 5;
   */
  CODE_STORAGE = 5,

  /**
   * REASON_CONTRACT_CREATION is the amount of gas that will be charged for a 'CREATE' opcode executed by the EVM and for the gas
   * burned for a CREATE, today controlled by EIP150 rules
   *
   * @generated from enum value: REASON_CONTRACT_CREATION = 6;
   */
  CONTRACT_CREATION = 6,

  /**
   * REASON_CONTRACT_CREATION2 is the amount of gas that will be charged for a 'CREATE2' opcode executed by the EVM and for the gas
   * burned for a CREATE2, today controlled by EIP150 rules
   *
   * @generated from enum value: REASON_CONTRACT_CREATION2 = 7;
   */
  CONTRACT_CREATION2 = 7,

  /**
   * REASON_DELEGATE_CALL is the amount of gas that will be charged for a 'DELEGATECALL' opcode executed by the EVM
   *
   * @generated from enum value: REASON_DELEGATE_CALL = 8;
   */
  DELEGATE_CALL = 8,

  /**
   * REASON_EVENT_LOG is the amount of gas that will be charged for a 'LOG<N>' opcode executed by the EVM
   *
   * @generated from enum value: REASON_EVENT_LOG = 9;
   */
  EVENT_LOG = 9,

  /**
   * REASON_EXT_CODE_COPY is the amount of gas that will be charged for a 'LOG<N>' opcode executed by the EVM
   *
   * @generated from enum value: REASON_EXT_CODE_COPY = 10;
   */
  EXT_CODE_COPY = 10,

  /**
   * REASON_FAILED_EXECUTION is the burning of the remaining gas when the execution failed without a revert
   *
   * @generated from enum value: REASON_FAILED_EXECUTION = 11;
   */
  FAILED_EXECUTION = 11,

  /**
   * REASON_INTRINSIC_GAS is the amount of gas that will be charged for the intrinsic cost of the transaction, there is
   * always exactly one of those per transaction
   *
   * @generated from enum value: REASON_INTRINSIC_GAS = 12;
   */
  INTRINSIC_GAS = 12,

  /**
   * GasChangePrecompiledContract is the amount of gas that will be charged for a precompiled contract execution
   *
   * @generated from enum value: REASON_PRECOMPILED_CONTRACT = 13;
   */
  PRECOMPILED_CONTRACT = 13,

  /**
   * REASON_REFUND_AFTER_EXECUTION is the amount of gas that will be refunded to the caller after the execution of the call,
   * if there is left over at the end of execution
   *
   * @generated from enum value: REASON_REFUND_AFTER_EXECUTION = 14;
   */
  REFUND_AFTER_EXECUTION = 14,

  /**
   * REASON_RETURN is the amount of gas that will be charged for a 'RETURN' opcode executed by the EVM
   *
   * @generated from enum value: REASON_RETURN = 15;
   */
  RETURN = 15,

  /**
   * REASON_RETURN_DATA_COPY is the amount of gas that will be charged for a 'RETURNDATACOPY' opcode executed by the EVM
   *
   * @generated from enum value: REASON_RETURN_DATA_COPY = 16;
   */
  RETURN_DATA_COPY = 16,

  /**
   * REASON_REVERT is the amount of gas that will be charged for a 'REVERT' opcode executed by the EVM
   *
   * @generated from enum value: REASON_REVERT = 17;
   */
  REVERT = 17,

  /**
   * REASON_SELF_DESTRUCT is the amount of gas that will be charged for a 'SELFDESTRUCT' opcode executed by the EVM
   *
   * @generated from enum value: REASON_SELF_DESTRUCT = 18;
   */
  SELF_DESTRUCT = 18,

  /**
   * REASON_STATIC_CALL is the amount of gas that will be charged for a 'STATICALL' opcode executed by the EVM
   *
   * @generated from enum value: REASON_STATIC_CALL = 19;
   */
  STATIC_CALL = 19,

  /**
   * REASON_STATE_COLD_ACCESS is the amount of gas that will be charged for a cold storage access as controlled by EIP2929 rules
   *
   * Added in Berlin fork (Geth 1.10+)
   *
   * @generated from enum value: REASON_STATE_COLD_ACCESS = 20;
   */
  STATE_COLD_ACCESS = 20,

  /**
   * REASON_TX_INITIAL_BALANCE is the initial balance for the call which will be equal to the gasLimit of the call
   *
   * Added as new tracing reason in Geth, available only on some chains
   *
   * @generated from enum value: REASON_TX_INITIAL_BALANCE = 21;
   */
  TX_INITIAL_BALANCE = 21,

  /**
   * REASON_TX_REFUNDS is the sum of all refunds which happened during the tx execution (e.g. storage slot being cleared)
   * this generates an increase in gas. There is only one such gas change per transaction.
   *
   * Added as new tracing reason in Geth, available only on some chains
   *
   * @generated from enum value: REASON_TX_REFUNDS = 22;
   */
  TX_REFUNDS = 22,

  /**
   * REASON_TX_LEFT_OVER_RETURNED is the amount of gas left over at the end of transaction's execution that will be returned
   * to the chain. This change will always be a negative change as we "drain" left over gas towards 0. If there was no gas
   * left at the end of execution, no such even will be emitted. The returned gas's value in Wei is returned to caller.
   * There is at most one of such gas change per transaction.
   *
   * Added as new tracing reason in Geth, available only on some chains
   *
   * @generated from enum value: REASON_TX_LEFT_OVER_RETURNED = 23;
   */
  TX_LEFT_OVER_RETURNED = 23,

  /**
   * REASON_CALL_INITIAL_BALANCE is the initial balance for the call which will be equal to the gasLimit of the call. There is only
   * one such gas change per call.
   *
   * Added as new tracing reason in Geth, available only on some chains
   *
   * @generated from enum value: REASON_CALL_INITIAL_BALANCE = 24;
   */
  CALL_INITIAL_BALANCE = 24,

  /**
   * REASON_CALL_LEFT_OVER_RETURNED is the amount of gas left over that will be returned to the caller, this change will always
   * be a negative change as we "drain" left over gas towards 0. If there was no gas left at the end of execution, no such even
   * will be emitted.
   *
   * @generated from enum value: REASON_CALL_LEFT_OVER_RETURNED = 25;
   */
  CALL_LEFT_OVER_RETURNED = 25,
}

/**
 * Describes the enum sf.ethereum.type.v2.GasChange.Reason.
 */
export const GasChange_ReasonSchema: GenEnum<GasChange_Reason> = /*@__PURE__*/
  enumDesc(file_sf_ethereum_type_v2_type, 15, 0);

/**
 * HeaderOnlyBlock is used to optimally unpack the [Block] structure (note the
 * corresponding message number for the `header` field) while consuming less
 * memory, when only the `header` is desired.
 *
 * WARN: this is a client-side optimization pattern and should be moved in the
 * consuming code.
 *
 * @generated from message sf.ethereum.type.v2.HeaderOnlyBlock
 */
export type HeaderOnlyBlock = Message<"sf.ethereum.type.v2.HeaderOnlyBlock"> & {
  /**
   * @generated from field: sf.ethereum.type.v2.BlockHeader header = 5;
   */
  header?: BlockHeader;
};

/**
 * Describes the message sf.ethereum.type.v2.HeaderOnlyBlock.
 * Use `create(HeaderOnlyBlockSchema)` to create a new message.
 */
export const HeaderOnlyBlockSchema: GenMessage<HeaderOnlyBlock> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 16);

/**
 * BlockWithRefs is a lightweight block, with traces and transactions
 * purged from the `block` within, and only.  It is used in transports
 * to pass block data around.
 *
 * @generated from message sf.ethereum.type.v2.BlockWithRefs
 */
export type BlockWithRefs = Message<"sf.ethereum.type.v2.BlockWithRefs"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: sf.ethereum.type.v2.Block block = 2;
   */
  block?: Block;

  /**
   * @generated from field: sf.ethereum.type.v2.TransactionRefs transaction_trace_refs = 3;
   */
  transactionTraceRefs?: TransactionRefs;

  /**
   * @generated from field: bool irreversible = 4;
   */
  irreversible: boolean;
};

/**
 * Describes the message sf.ethereum.type.v2.BlockWithRefs.
 * Use `create(BlockWithRefsSchema)` to create a new message.
 */
export const BlockWithRefsSchema: GenMessage<BlockWithRefs> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 17);

/**
 * @generated from message sf.ethereum.type.v2.TransactionTraceWithBlockRef
 */
export type TransactionTraceWithBlockRef = Message<"sf.ethereum.type.v2.TransactionTraceWithBlockRef"> & {
  /**
   * @generated from field: sf.ethereum.type.v2.TransactionTrace trace = 1;
   */
  trace?: TransactionTrace;

  /**
   * @generated from field: sf.ethereum.type.v2.BlockRef block_ref = 2;
   */
  blockRef?: BlockRef;
};

/**
 * Describes the message sf.ethereum.type.v2.TransactionTraceWithBlockRef.
 * Use `create(TransactionTraceWithBlockRefSchema)` to create a new message.
 */
export const TransactionTraceWithBlockRefSchema: GenMessage<TransactionTraceWithBlockRef> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 18);

/**
 * @generated from message sf.ethereum.type.v2.TransactionRefs
 */
export type TransactionRefs = Message<"sf.ethereum.type.v2.TransactionRefs"> & {
  /**
   * @generated from field: repeated bytes hashes = 1;
   */
  hashes: Uint8Array[];
};

/**
 * Describes the message sf.ethereum.type.v2.TransactionRefs.
 * Use `create(TransactionRefsSchema)` to create a new message.
 */
export const TransactionRefsSchema: GenMessage<TransactionRefs> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 19);

/**
 * @generated from message sf.ethereum.type.v2.BlockRef
 */
export type BlockRef = Message<"sf.ethereum.type.v2.BlockRef"> & {
  /**
   * @generated from field: bytes hash = 1;
   */
  hash: Uint8Array;

  /**
   * @generated from field: uint64 number = 2;
   */
  number: bigint;
};

/**
 * Describes the message sf.ethereum.type.v2.BlockRef.
 * Use `create(BlockRefSchema)` to create a new message.
 */
export const BlockRefSchema: GenMessage<BlockRef> = /*@__PURE__*/
  messageDesc(file_sf_ethereum_type_v2_type, 20);

/**
 * @generated from enum sf.ethereum.type.v2.TransactionTraceStatus
 */
export enum TransactionTraceStatus {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: SUCCEEDED = 1;
   */
  SUCCEEDED = 1,

  /**
   * @generated from enum value: FAILED = 2;
   */
  FAILED = 2,

  /**
   * @generated from enum value: REVERTED = 3;
   */
  REVERTED = 3,
}

/**
 * Describes the enum sf.ethereum.type.v2.TransactionTraceStatus.
 */
export const TransactionTraceStatusSchema: GenEnum<TransactionTraceStatus> = /*@__PURE__*/
  enumDesc(file_sf_ethereum_type_v2_type, 0);

/**
 * @generated from enum sf.ethereum.type.v2.CallType
 */
export enum CallType {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * direct? what's the name for `Call` alone?
   *
   * @generated from enum value: CALL = 1;
   */
  CALL = 1,

  /**
   * @generated from enum value: CALLCODE = 2;
   */
  CALLCODE = 2,

  /**
   * @generated from enum value: DELEGATE = 3;
   */
  DELEGATE = 3,

  /**
   * @generated from enum value: STATIC = 4;
   */
  STATIC = 4,

  /**
   * create2 ? any other form of calls?
   *
   * @generated from enum value: CREATE = 5;
   */
  CREATE = 5,
}

/**
 * Describes the enum sf.ethereum.type.v2.CallType.
 */
export const CallTypeSchema: GenEnum<CallType> = /*@__PURE__*/
  enumDesc(file_sf_ethereum_type_v2_type, 1);

